"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
const jwt = require("jsonwebtoken");
class KafkaLogger {
    constructor(options) {
        const defaultHeaders = {
            'Content-Type': 'application/vnd.kafka.json.v2+json',
            'Accept': 'application/vnd.kafka.v2+json'
        };
        this.options = Object.assign({}, options);
        if (!options.url)
            throw new Error('KafkaLogger: Missing URL');
        const parsedURL = url.parse(options.url);
        this.options.hostname = parsedURL.hostname;
        this.options.protocol = parsedURL.protocol;
        this.options.method = 'POST';
        if (typeof parsedURL.port !== 'undefined')
            this.options.port = parsedURL.port;
        this.options.headers = typeof this.options.headers !== 'undefined' ? Object.assign(Object.assign({}, defaultHeaders), this.options.headers) : defaultHeaders;
    }
    send(options) {
        try {
            const message = this.parseLogMessage(options);
            if ((message.REQUEST_URI || '').indexOf('/swagger') > -1 ||
                (message.REQUEST_URI || '').indexOf('/swaggerui') > -1 ||
                (message.REQUEST_URI || '').indexOf('/documentation') > -1 ||
                (message.REQUEST_URI || '').indexOf('.css') > -1 ||
                (message.REQUEST_URI || '').indexOf('.js') > -1 ||
                (message.REQUEST_URI || '').indexOf('.png') > -1 ||
                (message.REQUEST_URI || '').indexOf('.jpg') > -1 ||
                (message.REQUEST_URI || '').indexOf('.ico') > -1 ||
                (message.REQUEST_URI || '').indexOf('.html') > -1) {
                return;
            }
            const requestBody = this.getRequestBodyString(message);
            const topics = this.getTopics(options.topics);
            const requestOption = Object.assign({}, this.options, { path: `/topics/${topics}` });
            requestOption.headers = Object.assign(requestOption.headers, { 'Content-Length': Buffer.byteLength(requestBody) });
            const lib = requestOption.protocol.startsWith('https') ? require('https') : require('http');
            const request = lib.request(requestOption);
            request.on('response', (response) => response.on('end', () => { }).resume());
            request.on('error', (error) => console.warn('KafkaLogger', error));
            request.write(requestBody);
            request.end();
        }
        catch (error) {
            console.warn('KafkaLogger ', error);
        }
    }
    getTopics(topics) {
        try {
            const base = process.env.name ? process.env.name : require('path').basename(JSON.parse(process.env.LOG).PATH);
            return `${base}-${topics}`.toLowerCase().trim();
        }
        catch (error) {
            return 'mc-unknown';
        }
    }
    getRequestBodyString(message) {
        let record;
        try {
            let cache = [];
            record = JSON.stringify({ records: [{ value: message }] }, (key, value) => {
                if (typeof value === 'object' && value !== null) {
                    if (cache.indexOf(value) !== -1) {
                        return;
                    }
                    cache.push(value);
                }
                return value;
            });
            cache = null;
        }
        catch (error) {
            message.REQUEST_BODY = '';
            record = JSON.stringify(Object.assign({}, { records: [{ value: message }] }));
        }
        return record;
    }
    parseLogMessage(options) {
        let message = Object.assign({}, options.message);
        switch (options.topics) {
            case 'info':
                message = Object.assign({}, this.parseLogInfo(message));
                break;
            case 'service':
                message = Object.assign({}, this.parseLogService(message));
                break;
            default: break;
        }
        return message;
    }
    parseLogInfo(message) {
        const requestHeader = Object.assign({}, message.requestHeaders || {});
        const token = this.getToken(requestHeader);
        const header = Object.assign(requestHeader, { 'x-authorization': this.decodeJwt(token) });
        return {
            'TIMESTAMP': message.timestamp,
            'ID': message.id,
            'IP': message.ip,
            'REQUEST_ID': message.requestId,
            'REQUEST_METHOD': message.requestMethod,
            'REQUEST_URI': message.requestUri,
            'REQUEST_HEADER': header,
            'REQUEST_PARAMS': message.requestParams,
            'REQUEST_BODY': message.requestBody,
            'RESPONSE_STATUS': message.responseStatus,
            'RESPONSE_BODY': message.responseBody,
            'RESPONSE_TIME': message.responseTime,
            'CLIENT_MODULE': message.clientModule,
            'CLIENT_PAGE_NAME': message.clientPageName,
            'CLIENT_ACTION': message.clientAction,
            'CLIENT_PAGE_URL': message.clientPageUrl,
        };
    }
    getToken(requestHeader) {
        let token;
        try {
            token = (requestHeader && requestHeader['x-authorization']) ? requestHeader['x-authorization'] : '';
            token = token.split(' ')[1];
        }
        catch (error) {
            token = '';
        }
        return token;
    }
    parseLogService(message) {
        const requestHeader = Object.assign({}, message.requestHeaders || {});
        const token = this.getToken(requestHeader);
        const header = Object.assign(requestHeader, { 'x-authorization': this.decodeJwt(token) });
        return {
            'SERVICE_ENDPOINT': (message && message.name) ? message.name : '-',
            'TIMESTAMP': message.timestamp,
            'ID': message.id,
            'IP': message.ip,
            'REQUEST_ID': message.requestId,
            'REQUEST_METHOD': message.requestMethod,
            'REQUEST_URI': message.requestUri,
            'REQUEST_HEADER': header,
            'REQUEST_PARAMS': message.requestParams,
            'REQUEST_BODY': message.requestBody,
            'RESPONSE_STATUS': message.responseStatus,
            'RESPONSE_BODY': message.responseBody,
            'RESPONSE_TIME': message.responseTime,
            'ERROR_MESSAGE': message.errorMessage,
            'ERROR_INSTANCE': message.errorInstance,
        };
    }
    decodeJwt(token) {
        const decoded = jwt.decode(token, { complete: true });
        try {
            return JSON.stringify(decoded.payload);
        }
        catch (error) {
            return token;
        }
    }
}
exports.KafkaLogger = KafkaLogger;
