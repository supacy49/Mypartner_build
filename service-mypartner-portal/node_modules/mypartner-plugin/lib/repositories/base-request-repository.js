"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Moment = require("moment");
const Request = require("request-promise");
const Boom = require("boom");
require('tls').DEFAULT_CIPHERS = 'RSA';
class BaseRequestRepository {
    constructor(server, options) {
        this.getConnection = () => {
            return this.server.plugins['hapi-mongoose'].connection;
        };
        this._getLoggerData = (reqOptions, loggerName, startTime, response, error) => {
            let now = Moment();
            let data = {
                name: loggerName,
                timestamp: now.format('YYYY-MM-DD HH:mm:ss'),
                request: {
                    id: reqOptions['id'],
                    ip: reqOptions['ip'],
                    apiRequestId: reqOptions['headers']['x-ssb-transaction-id'],
                    method: reqOptions['method'],
                    uri: reqOptions['uri'],
                    headers: reqOptions['headers'],
                    params: reqOptions['qs'],
                    body: reqOptions['body']
                },
                response: {
                    status: response ? response.statusCode : error.statusCode,
                    body: response ? response.body : null,
                    time: Moment.duration(now.diff(startTime)).asMilliseconds()
                },
                error: {
                    message: error ? error.message : null,
                    instance: error ? error.name : null
                }
            };
            // console.log('data', data);
            return data;
        };
        this._getReqOptionsPost = (request) => {
            return {
                method: 'POST',
                id: request.id,
                apiRequestId: request.apiRequestId,
                headers: this.options.headers,
                resolveWithFullResponse: true,
                timeout: this.options['timeout'] || 2000
            };
        };
        this._getReqOptionsPostWithoutHeader = (request) => {
            return {
                method: 'POST',
                id: request.id,
                apiRequestId: request.apiRequestId,
                headers: {},
                resolveWithFullResponse: true,
                timeout: this.options['timeout'] || 2000
            };
        };
        this._getReqOptionsGet = (request) => {
            return {
                method: 'GET',
                id: request.id,
                headers: this.options.headers,
                resolveWithFullResponse: true,
                timeout: this.options['timeout'] || 2000
            };
        };
        this.sendLog = (reqOptions, loggerName, response) => {
            let now = Moment();
            console.log('send : ', reqOptions);
            this.server.emit('service', this._getLoggerData(reqOptions, loggerName, now, response, null));
        };
        this.sendRequest = (reqOptions, loggerName) => {
            let responsePromise;
            //if (this.options['eventName']) {
            let now = Moment();
            let logResponse = null;
            let logError = null;
            let logReq=JSON.parse(JSON.stringify(reqOptions));
            reqOptions['headers']['x-ssb-transaction-id'] = now.format('YYYYMMDDHHmmssSSS');
            try {
            if (typeof logReq.body.password !="undefined")
            {logReq.body.password="***";}
            }
            catch(err){}
            //console.log('send : ', reqOptions);
            console.log('send_ ',loggerName, ' _ : ', logReq);
           // console.log('send : ', reqOptions);
            responsePromise = Request(reqOptions)
                .then(response => {
                logResponse = response;
                this.server.emit('service', this._getLoggerData(logReq, loggerName, now, response, null));
                console.log('response==========> : ', response.body);
                return response;
            })
                .catch(error => {
                logError = error;
                this.server.emit('service', this._getLoggerData(logReq, loggerName, now, null, error));
                console.log('error==========> : ', error);
                throw error;
            });
            return responsePromise.then(this._validateJsonObject);
        };
        // protected sendRequest = (reqOptions: any, loggerName: string) => {
        //     // let responsePromise
        //     //if (this.options['eventName']) {
        //     let now = Moment()
        //     let logResponse = null
        //     let logError = null
        //     console.log('send : ', reqOptions)
        //     var parseUrl = Url.parse(reqOptions.uri);
        //     var options = {
        //       "method": reqOptions.method,
        //       "hostname": parseUrl.host,
        //       "port": null,
        //       "path": parseUrl.path,
        //       "headers": reqOptions.headers
        //     }
        //     console.log("Option http params ===>", options)
        //     var responsePromise;
        //     switch (reqOptions.method) {
        //       case "GET":{
        //         responsePromise = new Promise(function(resolve, reject) {
        //           var req = Http.request(options, function (res) {
        //             var chunks = [];
        //             res.on("data", function (chunk) {
        //               chunks.push(chunk);
        //             });
        //             res.on("end", function () {
        //               var body = Buffer.concat(chunks);
        //               var obj = {}
        //               obj["body"] = JSON.parse(body.toString());
        //               console.log("obj ===>", obj)
        //               resolve(obj);
        //             });
        //           });
        //           req.end();
        //         });
        //         break;
        //       }
        //       case "POST":{
        //         responsePromise = new Promise(function(resolve, reject) {
        //           var req = Http.request(options, function (res) {
        //             var chunks = [];
        //             res.on("data", function (chunk) {
        //               chunks.push(chunk);
        //             });
        //             res.on("end", function () {
        //               var body = Buffer.concat(chunks);
        //               var obj = {}
        //               obj["body"] = JSON.parse(body.toString());
        //               resolve(obj);
        //             });
        //           });
        //           req.write(JSON.stringify(reqOptions.body));
        //             req.end();
        //           });
        //         break;
        //       }
        //       default: { 
        //         console.log('other method')
        //         break; 
        //       } 
        //     }
        //     return responsePromise.then(this._validateJsonObject)
        //   }
        this._validateJsonObject = response => {
            let body = response.body;
            console.log(body);
            if (typeof body == 'object') {
                return response;
            }
            else {
                throw Boom.create(500, 'JsonFormatError', {
                    name: 'JsonFormatError',
                    message: 'Incorrect JSON response',
                    body: body
                });
            }
        };
        this.server = server;
        this.options = options;
    }
}
exports.BaseRequestRepository = BaseRequestRepository;
//# sourceMappingURL=base-request-repository.js.map