"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base_repository_1 = require("./base-repository");
const Crypto = require("crypto");
class UserRepository extends base_repository_1.BaseRepository {
    constructor() {
        super(...arguments);
        this.registerMethod = () => {
            console.log('regis user');
            this
                .server
                .method({
                name: 'Regis.saveUser',
                method: this.saveUser,
                options: {
                    callback: false
                }
            });
            this
                .server
                .method({
                name: 'Regis.keepAlive',
                method: this.keepAlive,
                options: {
                    callback: false
                }
            });
            this
                .server
                .method({
                name: 'Regis.validateSession',
                method: this.validateSession,
                options: {
                    callback: false
                }
            });
            this
                .server
                .method({
                name: 'Regis.getUserToken',
                method: this.getUserToken,
                options: {
                    callback: false
                }
            });
            this
                .server
                .method({
                name: 'Regis.getEncryptToken',
                method: this.getEncryptToken,
                options: {
                    callback: false
                }
            });
        };
        this.saveUser = (request) => {
            let userRequestOptions = {
                SESSION_ID: request.payload.sessionId,
                USERNAME: request.payload.username,
                FULLNAME: request.payload.fullname,
                ROLE: request.payload.role,
                PARAMETER_TYPE: request.payload.type,
                PARAMETER_VALUE: request.payload.value,
                MY_CHANNEL_TOKEN: request.payload.myChannelToken
            };
            return this._saveUser(request, userRequestOptions);
        };
        this._saveUser = (request, userRequestOptions) => {
            let reqOptions = this._getReqOptionsPost(request);
            reqOptions['uri'] = "/api/saveUser";
            reqOptions['headers']['Content-Type'] = 'application/json';
            reqOptions['body'] = {
                sessionId: userRequestOptions.SESSION_ID,
                username: userRequestOptions.USERNAME,
                fullname: userRequestOptions.FULLNAME,
                role: userRequestOptions.ROLE,
                type: userRequestOptions.PARAMETER_TYPE,
                value: userRequestOptions.PARAMETER_VALUE,
                myChannelToken: userRequestOptions.MY_CHANNEL_TOKEN
            };
            const loggerName = 'mychannel-service';
            var $this = this;
            let db = this.getConnection();
            let responsePromise = new Promise(function (resolve, reject) {
                db.model('User').findOne({ USERNAME: userRequestOptions.USERNAME }).exec().then((user) => {
                    var obj = {};
                    if (user) {
                        db.model('User').findById(user["_id"], function (err, existUser) {
                            existUser.set(userRequestOptions);
                            existUser.save(function (err, updatedUser) {
                                obj["body"] = updatedUser;
                                $this.sendLog(reqOptions, loggerName, obj);
                                resolve(obj);
                            });
                        });
                    }
                    else {
                        let result = $this.createUser(userRequestOptions);
                        obj["body"] = result;
                        resolve(obj);
                    }
                });
            });
            return responsePromise;
        };
        this.createUser = (userObj) => {
            let db = this.getConnection();
            const User = db.model('User');
            const user = new User(userObj);
            user.save();
        };
        this.validateSession = (request) => {
            let keepAliveRequestOptions = {
                TOKEN: request.payload.token,
                ACTION: request.payload.action
            };
            return this._validateSession(request, keepAliveRequestOptions);
        };
        this._validateSession = (request, keepAliveRequestOptions) => {
            let reqOptions = this._getReqOptionsPost(request);
            reqOptions['uri'] = "/api/validateSession";
            reqOptions['headers']['Content-Type'] = 'application/json';
            reqOptions['body'] = {
                token: keepAliveRequestOptions.TOKEN,
                action: keepAliveRequestOptions.ACTION,
            };
            const loggerName = 'mychannel-service';
            var $this = this;
            let db = this.getConnection();
            let token = keepAliveRequestOptions.TOKEN;
            var textString = this.decryptUserToken(token);
            let arrayToken = textString.split("|");
            let myChannelToken = arrayToken[7];
            let responsePromise = new Promise(function (resolve, reject) {
                db.model('User').findOne({ MY_CHANNEL_TOKEN: myChannelToken }).exec().then((user) => {
                    if (user) {
                        // let obj = { "body": { "statusCode": "200", "message": "ok" } }
                        let obj = {
                            "body": {
                                "resultCode": "20000",
                                "resultDescription": "Success",
                                "developerMessage": "Success",
                                "data": {
                                    "statusCode": "200",
                                    "message": "ok"
                                }
                            }
                        };
                        $this.sendLog(reqOptions, loggerName, obj);
                        resolve(obj);
                    }
                    else {
                        // let obj = { "body": { "statusCode": "403", "message": "User Invalid!" } }
                        let obj = {
                            "body": {
                                "resultCode": "MYCHN00140300",
                                "resultDescription": "User Invalid!",
                                "developerMessage": "User Invalid!",
                                "errors": {
                                    "statusCode": 403,
                                    "error": "Forbidden",
                                    "message": "User Invalid!"
                                }
                            }
                        };
                        $this.sendLog(reqOptions, loggerName, obj);
                        resolve(obj);
                    }
                });
            });
            return responsePromise;
        };
        this.keepAlive = (request) => {
            let keepAliveRequestOptions = {
                TOKEN: request.payload.token,
                ACTION: request.payload.action
            };
            return this._keepAlive(request, keepAliveRequestOptions);
        };
        this._keepAlive = (request, keepAliveRequestOptions) => {
            let reqOptions = this._getReqOptionsPost(request);
            reqOptions['uri'] = "/api/keepAlive";
            reqOptions['headers']['Content-Type'] = 'application/json';
            reqOptions['body'] = {
                token: keepAliveRequestOptions.TOKEN,
                action: keepAliveRequestOptions.ACTION,
            };
            const loggerName = 'mychannel-service';
            var $this = this;
            let db = this.getConnection();
            let token = keepAliveRequestOptions.TOKEN;
            var textString = this.decryptUserToken(token);
            let arrayToken = textString.split("|");
            let myChannelToken = arrayToken[7];
            let responsePromise = new Promise(function (resolve, reject) {
                db.model('User').findOne({ MY_CHANNEL_TOKEN: myChannelToken }).exec().then((user) => {
                    if (user) {
                        let obj = { "body": { "statusCode": "200", "message": "ok" } };
                        $this.sendLog(reqOptions, loggerName, obj);
                        resolve(obj);
                    }
                    else {
                        let obj = { "body": { "statusCode": "403", "message": "User Invalid!" } };
                        $this.sendLog(reqOptions, loggerName, obj);
                        resolve(obj);
                    }
                });
            });
            return responsePromise;
        };
        this.getEncryptToken = (request) => {
            let getEncryptTokenParamsOptions = {
                username: request.payload.username,
                location: request.payload.location,
                extSystem: request.payload.extSystem
            };
            return this._getEncryptToken(request, getEncryptTokenParamsOptions);
        };
        this._getEncryptToken = (request, getEncryptTokenParamsOptions) => {
            let reqOptions = this._getReqOptionsPost(request);
            reqOptions['uri'] = "/api/getEncryptToken";
            reqOptions['headers']['Content-Type'] = 'application/json';
            reqOptions['body'] = {
                username: getEncryptTokenParamsOptions.username,
                location: getEncryptTokenParamsOptions.location,
                extSystem: getEncryptTokenParamsOptions.extSystem
            };
            const loggerName = 'mychannel-service';
            var $this = this;
            console.log("reqOptions", reqOptions);
            let responsePromise = new Promise(function (resolve, reject) {
                let params = "?user=" + encodeURIComponent($this.encryptString(getEncryptTokenParamsOptions.username)) +
                    "&locCode=" + encodeURIComponent($this.encryptString(getEncryptTokenParamsOptions.location)) +
                    "&extSystem=" + encodeURIComponent($this.encryptString(getEncryptTokenParamsOptions.extSystem));
                let obj = {
                    "body": {
                        "resultCode": "S",
                        "resultMessage": "Success",
                        "bypassUrl": $this.options['tdmUrl'] +
                            $this.options.urlList['x-path-getEncryptToken'] +
                            params
                    }
                };
                $this.sendLog(reqOptions, loggerName, obj);
                resolve(obj);
            });
            return responsePromise;
        };
        this.getUserToken = (request) => {
            let getUserTokenParamsOptions = {
                MY_CHANNEL_TOKEN: request.payload.myChannelToken,
            };
            return this._getUserToken(request, getUserTokenParamsOptions);
        };
        this._getUserToken = (request, getUserTokenParamsOptions) => {
            let reqOptions = this._getReqOptionsPost(request);
            reqOptions['uri'] = "/api/getUserToken";
            reqOptions['headers']['Content-Type'] = 'application/json';
            reqOptions['body'] = {
                myChannelToken: getUserTokenParamsOptions.MY_CHANNEL_TOKEN,
            };
            const loggerName = 'mychannel-service';
            var $this = this;
            console.log("reqOptions", reqOptions);
            let db = this.getConnection();
            let myChannelToken = getUserTokenParamsOptions.MY_CHANNEL_TOKEN;
            let responsePromise = new Promise(function (resolve, reject) {
                db.model('User').findOne({ MY_CHANNEL_TOKEN: myChannelToken }).exec().then((user) => {
                    if (user) {
                        let obj = {
                            "body": {
                                "resultCode": "S",
                                "resultMessage": "Success",
                                "token": $this.encryptUserToken(user)
                            }
                        };
                        $this.sendLog(reqOptions, loggerName, obj);
                        resolve(obj);
                    }
                    else {
                        let obj = {
                            "body": {
                                "resultCode": "F",
                                "resultMessage": "Fail"
                            }
                        };
                        $this.sendLog(reqOptions, loggerName, obj);
                        resolve(obj);
                    }
                });
            });
            return responsePromise;
        };
        this.encryptUserToken = (user) => {
            let opt = this.options;
            var aesDataMessage = user.SESSION_ID + "|"
                + user.USERNAME + "|"
                + user.FULLNAME + "|"
                + user.ROLE + "|"
                + user.PARAMETER_TYPE + "|"
                + user.PARAMETER_VALUE + "|"
                + opt.urlList["x-path-redirect"] + "|"
                + user.MY_CHANNEL_TOKEN;
            var cipher = Crypto.createCipheriv('aes-128-ecb', this.padString(opt.token['secret-token']), '');
            var crypted = cipher.update(aesDataMessage, 'utf-8', 'base64');
            crypted += cipher.final('base64');
            return crypted;
        };
        this.decryptUserToken = (token) => {
            var decipher = Crypto.createDecipheriv('aes-128-ecb', this.padString(this.options.token['secret-token']), '');
            var decrypted = decipher.update(token, 'base64');
            decrypted += decipher.final();
            return decrypted;
        };
        this.encryptString = (text) => {
            let opt = this.options;
            var cipher = Crypto.createCipheriv('aes-128-ecb', this.padString(opt.token['secret-token']), '');
            var crypted = cipher.update(text, 'utf-8', 'base64');
            crypted += cipher.final('base64');
            return crypted;
        };
    }
    padString(str) {
        var range = 16;
        var length = (str.length % range);
        var i = (range - length);
        if ((i > 0) && (i < range)) {
            for (var j = (range - length); j > 0; j--) {
                str += ' ';
            }
        }
        return str;
    }
}
exports.UserRepository = UserRepository;
//# sourceMappingURL=user-repository.js.map