"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Moment = require("moment");
const logger_1 = require("./logger");
const kafka_1 = require("./kafka");
class EventLogger {
    static init(server, eventOption) {
        this.logger = new logger_1.default(eventOption.log);
        this.kafkaLogger = new kafka_1.KafkaLogger({ url: eventOption['kafkaUrl'] || 'https://10.138.46.127:80' });
        server.on('request-internal', (request, event, tags) => {
            try {
                if (event.tags[0] === 'received') {
                    this.logger.accessLog({
                        timestamp: Moment(request.info.received).format(this.timestampFormat),
                        id: request.id,
                        ip: request.headers['x-forwarded-for'] || request.info.remoteAddress,
                        requestId: request.headers['x-api-request-id'] || '',
                        requestMethod: request
                            .method
                            .toUpperCase(),
                        requestUri: request.path,
                        requestHeaders: request.headers,
                        requestParams: request.url.query,
                        requestBody: this.logBody(request.payload, eventOption.hiddenFields)
                    });
                }
            }
            catch (err) {
                this.handleLogError(err, {
                    timestamp: Moment(request.info.received).format(this.timestampFormat),
                    id: request.id,
                    ip: request.headers['x-forwarded-for'] || request.info.remoteAddress,
                    requestId: request.headers['x-api-request-id'] || ''
                });
            }
        });
        server.on('response', (request) => {
            let headers = request.headers;
            try {
                const _log = {
                    timestamp: Moment(request.info.received).format(this.timestampFormat),
                    id: request.id,
                    ip: headers['x-forwarded-for'] || request.info.remoteAddress,
                    requestId: headers['x-api-request-id'] || '',
                    requestMethod: request
                        .method
                        .toUpperCase(),
                    requestUri: request.path,
                    requestHeaders: headers,
                    requestParams: request.url.query,
                    requestBody: this.logBody(request.payload, eventOption.hiddenFields, eventOption.hiddenPin),
                    responseStatus: request.response.statusCode,
                    responseBody: request.response.source,
                    responseTime: this.calculateResponseTime(request),
                    clientModule: headers['x-client-module'] || '',
                    clientPageName: headers['x-client-page-name'] || '',
                    clientAction: headers['x-client-action'] || '',
                    clientPageUrl: headers['x-client-page-url'] || ''
                };
                this.logger.infoLog(_log);
                if (eventOption && eventOption.kafkaEnable) {
                    this.kafkaLogger.send({ topics: 'info', message: _log });
                }
            }
            catch (err) {
                this.handleLogError(err, {
                    timestamp: Moment(request.info.received).format(this.timestampFormat),
                    id: request.id,
                    ip: request.headers['x-forwarded-for'] || request.info.remoteAddress,
                    requestId: request.headers['x-api-request-id'] || ''
                });
            }
        });
        server.on('request-error', (request, err) => {
            try {
                let _logMessage;
                if (err.data) {
                    if (err.data.body) {
                        _logMessage = JSON.stringify(err.data);
                    }
                    else {
                        _logMessage = err.data.stack || err.data.message;
                    }
                }
                else {
                    _logMessage = err.stack || err.message;
                }
                this.logger.rootLog({
                    timestamp: Moment(request.info.received).format(this.timestampFormat),
                    id: request.id,
                    ip: request.headers['x-forwarded-for'] || request.info.remoteAddress,
                    requestId: request.headers['x-api-request-id'] || '',
                    logMessage: _logMessage
                });
            }
            catch (err) {
                this.handleLogError(err, {
                    timestamp: Moment(request.info.received).format(this.timestampFormat),
                    id: request.id,
                    ip: request.headers['x-forwarded-for'] || request.info.remoteAddress,
                    requestId: request.headers['x-api-request-id'] || ''
                });
            }
        });
        server.event('service');
        server.on('service', (data, err) => {
            try {
                const _log = {
                    name: data.name,
                    timestamp: Moment(data.timestamp).format(this.timestampFormat),
                    id: data.request.id,
                    ip: data.request.ip,
                    requestId: data.request.apiRequestId,
                    requestMethod: data
                        .request
                        .method
                        .toUpperCase(),
                    requestUri: data.request.uri,
                    requestHeaders: data.request.headers,
                    requestParams: data.request.params,
                    requestBody: this.logBody(data.request.body, eventOption.hiddenFields, eventOption.hiddenPin),
                    responseStatus: data.response.status,
                    responseBody: this.logBody(data.response.body, eventOption.hiddenFields),
                    responseTime: data.response.time,
                    errorMessage: data.error.message,
                    errorInstance: data.error.instance,
                    userName: data.request.body.username || data.request.body.userName || ''
                };
                this.logger.serviceLog(_log);
                if (eventOption && eventOption.kafkaEnable) {
                    this.kafkaLogger.send({ topics: 'service', message: _log });
                }
            }
            catch (err) {
                this.handleLogError(err, {
                    timestamp: Moment(data.timestamp).format(this.timestampFormat),
                    id: data.request.id,
                    ip: data.request.ip,
                    requestId: data.request.apiRequestId
                });
            }
        });
    }
    static handleLogError(err, requestInfo) {
        this.logger.rootLog({
            timestamp: requestInfo.timestamp,
            id: requestInfo.id,
            ip: requestInfo.ip,
            requestId: requestInfo.requestId,
            logMessage: err.stack || err.message
        });
    }
    static isObject(obj) {
        return obj && typeof obj === 'object' && !Array.isArray(obj);
    }
    static isString(obj) {
        return obj && typeof obj === 'string';
    }
    static logBody(requestBody, hiddenFields, hiddenPin) {
        if (this.isObject(requestBody)) {
            hiddenFields
                .forEach((field) => {
                if (requestBody.hasOwnProperty(field)) {
                    requestBody[field] = '***';
                }
            });
            if (hiddenPin && hiddenPin.length > 0) {
                for (let word of hiddenPin) {
                    if (requestBody.hasOwnProperty(word.field)) {
                        requestBody[word.field] = requestBody[word.field].replace(requestBody[word.field].substring(word.start, word.end), 'xxxx');
                    }
                }
            }
        }
        else if (this.isString(requestBody)) {
            if (hiddenPin && hiddenPin.length > 0) {
                for (let word of hiddenPin) {
                    let match = requestBody.match(new RegExp(`(${word.field.toUpperCase()})([^(&amp;|&)]+)`));
                    if (match) {
                        let splitWord = match[0].split('=');
                        let replaceWord = splitWord[1].replace(splitWord[1].substring(1, 5), 'xxxx');
                        requestBody = requestBody.replace(splitWord[1], replaceWord);
                    }
                }
            }
        }
        return requestBody;
    }
    static calculateResponseTime(request) {
        let received = Moment(request.info.received);
        let responded = Moment(request.info.responded);
        let duration = Moment.duration(responded.diff(received));
        return duration.asMilliseconds();
    }
}
exports.EventLogger = EventLogger;
EventLogger.timestampFormat = "YYYY-MM-DD HH:mm:ss.SSS";
