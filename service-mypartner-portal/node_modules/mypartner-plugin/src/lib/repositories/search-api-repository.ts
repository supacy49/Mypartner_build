import * as Bluebird from "bluebird";
import * as Moment from 'moment'
import * as Cron from 'cron'
import {BaseRequestRepository} from "./base-request-repository"
import {
    SearchApiParams, 
    IRepository, 
    IRequest
} from "./../interfaces"
require('tls').DEFAULT_CIPHERS= 'RSA'

export class SearchApiRepository extends BaseRequestRepository implements IRepository {

    public registerMethod = (): void => {
        this.server.method({
            name: 'Regis.searchApi',
            method: this.searchApi,
            options: {
              callback: false
            }
        })

        this.server.method({
            name: 'Regis.getSearchApi',
            method: this.getSearchApi,
            options: {
              callback: false
            }
        })

        this.server.method({
            name: 'Regis.cronJob',
            method: this.cronJob,
            options: {
              callback: false
            }
        })
        
    }

    private cronJob = (request: any) => {
        var CronJob = Cron.CronJob;
        var self = this
        new CronJob(this.options.cron['recurring'], function () {
            self._saveQuerySearchApiByTag(request, "MostviewConfirm")
            self._saveQuerySearchApiByTag(request, "BestsellerConfirm")
        }, null, true, 'Asia/Bangkok');
    }

    private _saveQuerySearchApiByTag = (request: any, tag: string) => {
        var self = this
        let searchApiQueryOptions: SearchApiParams = {
            consumer: self.options.token['consumer-token'],
            tags: tag
        }
        var count = 1
        self._querySearchApi(request, searchApiQueryOptions).then(result => {
            var response = self._saveProductData(result, searchApiQueryOptions)
            response.then(result => {
                if(!result){
                    self._querySearchApi(request, searchApiQueryOptions).then(result =>{
                        self._saveProductData(result, searchApiQueryOptions).then(result => {
                            if(!result){
                                self._querySearchApi(request, searchApiQueryOptions).then(result =>{
                                    self._saveProductData(result, searchApiQueryOptions)
                                })
                            }
                        })
                    })
                }
            })
        })
    
    }
    
    private searchApi = (request: any) => {
        let searchApiQueryOptions: SearchApiParams = {
            consumer: request.payload.consumer,
            tags: request.payload.tags
        }
        return this._querySearchApi(request, searchApiQueryOptions)
    }

    private _querySearchApi = (request: IRequest, searchApiQueryOptions: SearchApiParams) => {
        let reqOptions = this._getReqOptionsPostWithoutHeader(request)
        let now = Moment()
        reqOptions['certificate'] = 'tradingservice3.ais.co.th_2017.cer'
        reqOptions['rejectUnauthorized'] = false

        reqOptions['uri'] = this.options['cpcUrl'] + this.options.urlList['x-path-searchApi']
        reqOptions['headers']['Host'] = this.options.headers['Host']
        reqOptions['headers']['Content-Type'] = 'application/json'
        reqOptions['body'] = {
            consumer: searchApiQueryOptions.consumer,
            tags: searchApiQueryOptions.tags
        }
        reqOptions['json'] = true
        const loggerName = 'cpc-service'
        return this.sendRequest(reqOptions, loggerName)
    }

    private _saveProductData(res: any, searchApiQueryOptions: SearchApiParams): Bluebird<any> {
        var response = false
        var self = this
        var promise = new Promise(function(resolve, reject) {
            let body = res.body
            if (body.statusCode === "20000" && body.statusCode !== undefined) {
                let products = body.products
                if(products.length > 0) {
                    let db: any  = self.getConnection();  
                    const Product = db.model('Product');
                    Product.remove({"TAG": searchApiQueryOptions.tags}, (err) => {
                        if(err === null){
                            products.forEach((element, index) => {
                                let productObj =  {
                                    ROW_ID: "row_"+ searchApiQueryOptions.tags.toLowerCase() + "_" + index,
                                    TAG: searchApiQueryOptions.tags,
                                    PRODUCT_ID: element.product_id,
                                    NAME: element.name,
                                    ATTRIBUTES: element.attributes,
                                    IMAGES: element.images,
                                    THUMBNAIL: element.thumbnail,
                                    VARIATIONS: element.variations,
                                    PRICE: element.price
                                }
                                let product = new Product(productObj);
                                product.save()  
                            });
                        }
                    })
                    response = true
                }
            } else {
                response = false
            }
            resolve(response)
        });
        return promise
    }

    private getSearchApi= (request: any) => {
        let searchApiQueryOptions: SearchApiParams = {
            tags: request.payload.tags
        }
        return this._queryGetSearchApi(request, searchApiQueryOptions)
    }

    private _queryGetSearchApi = (request: IRequest, searchApiQueryOptions: SearchApiParams): Bluebird<any> => {
        let reqOptions = this._getReqOptionsPost(request)
        reqOptions['uri'] = "/api/getUserToken";
        reqOptions['headers']['Content-Type'] = 'application/json'
        reqOptions['body'] = {
            tags: searchApiQueryOptions.tags,
        }
        const loggerName = 'mychannel-service'

        var $this = this
        console.log("reqOptions", reqOptions)
        let db: any  = this.getConnection();
        let tags = searchApiQueryOptions.tags
        let responsePromise = new Promise(function(resolve, reject) {
            db.model('Product').find({TAG: tags}).exec().then((products) => {
                let obj = {
                    "body": {
                        "resultCode": "S",
                        "resultMessage": "Success",
                        "products": products
                    }
                }
                $this.sendLog(reqOptions, loggerName, obj)
                resolve(obj)
            });            
        });
        return responsePromise
    }

}
