import * as Moment from "moment";
import * as Hapi from 'hapi';
import * as Path from 'path';
import Logger from "./logger";
import { IEventOption, ILoggerData, IErrorLog, IOption } from "./interfaces";
import { KafkaLogger } from "./kafka";

export class EventLogger {
    private static timestampFormat: string = "YYYY-MM-DD HH:mm:ss.SSS";
    private static logger: Logger;
    private static kafkaLogger: KafkaLogger;

    public static init(server: any, eventOption: IEventOption): void {
        this.logger = new Logger(eventOption.log);
        this.kafkaLogger = new KafkaLogger({ url: eventOption['kafkaUrl'] || 'https://10.138.46.127:80' });

        server.on('request-internal', (request: Hapi.Request, event: any, tags: any) => {
            try {
                if (event.tags[0] === 'received') {
                    this.logger.accessLog({
                        timestamp: Moment(request.info.received).format(this.timestampFormat),
                        id: request.id,
                        ip: request.headers['x-forwarded-for'] || request.info.remoteAddress,
                        requestId: request.headers['x-api-request-id'] || '',
                        requestMethod: request
                            .method
                            .toUpperCase(),
                        requestUri: request.path,
                        requestHeaders: request.headers,
                        requestParams: request.url.query,
                        requestBody: this.logBody(request.payload, eventOption.hiddenFields)
                    });
                }
            } catch (err) {
                this.handleLogError(err, {
                    timestamp: Moment(request.info.received).format(this.timestampFormat),
                    id: request.id,
                    ip: request.headers['x-forwarded-for'] || request.info.remoteAddress,
                    requestId: request.headers['x-api-request-id'] || ''
                });
            }
        });

        server.on('response', (request: Hapi.Request) => {
            let headers: any = request.headers;

            try {
                const _log = {
                    timestamp: Moment(request.info.received).format(this.timestampFormat),
                    id: request.id,
                    ip: headers['x-forwarded-for'] || request.info.remoteAddress,
                    requestId: headers['x-api-request-id'] || '',
                    requestMethod: request
                        .method
                        .toUpperCase(),
                    requestUri: request.path,
                    requestHeaders: headers,
                    requestParams: request.url.query,
                    requestBody: this.logBody(request.payload, eventOption.hiddenFields, eventOption.hiddenPin),
                    responseStatus: request.response.statusCode,
                    responseBody: request.response.source,
                    responseTime: this.calculateResponseTime(request),
                    clientModule: headers['x-client-module'] || '',
                    clientPageName: headers['x-client-page-name'] || '',
                    clientAction: headers['x-client-action'] || '',
                    clientPageUrl: headers['x-client-page-url'] || ''
                }
                this.logger.infoLog(_log);
                if (eventOption && eventOption.kafkaEnable) {
                    this.kafkaLogger.send({ topics: 'info', message: _log });
                }
            } catch (err) {
                this.handleLogError(err, {
                    timestamp: Moment(request.info.received).format(this.timestampFormat),
                    id: request.id,
                    ip: request.headers['x-forwarded-for'] || request.info.remoteAddress,
                    requestId: request.headers['x-api-request-id'] || ''
                });
            }
        });

        server.on('request-error', (request: Hapi.Request, err: any) => {
            try {
                let _logMessage: string;

                if (err.data) {
                    if (err.data.body) {
                        _logMessage = JSON.stringify(err.data);
                    } else {
                        _logMessage = err.data.stack || err.data.message;
                    }
                } else {
                    _logMessage = err.stack || err.message;
                }

                this.logger.rootLog({
                    timestamp: Moment(request.info.received).format(this.timestampFormat),
                    id: request.id,
                    ip: request.headers['x-forwarded-for'] || request.info.remoteAddress,
                    requestId: request.headers['x-api-request-id'] || '',
                    logMessage: _logMessage
                });
            } catch (err) {
                this.handleLogError(err, {
                    timestamp: Moment(request.info.received).format(this.timestampFormat),
                    id: request.id,
                    ip: request.headers['x-forwarded-for'] || request.info.remoteAddress,
                    requestId: request.headers['x-api-request-id'] || ''
                });
            }
        });

        server.event('service');
        server.on('service', (data: ILoggerData, err: Error) => {
            try {
                const _log = {
                    name: data.name,
                    timestamp: Moment(data.timestamp).format(this.timestampFormat),
                    id: data.request.id,
                    ip: data.request.ip,
                    requestId: data.request.apiRequestId,
                    requestMethod: data
                        .request
                        .method
                        .toUpperCase(),
                    requestUri: data.request.uri,
                    requestHeaders: data.request.headers,
                    requestParams: data.request.params,
                    requestBody: this.logBody(data.request.body, eventOption.hiddenFields, eventOption.hiddenPin),
                    responseStatus: data.response.status,
                    responseBody: this.logBody(data.response.body, eventOption.hiddenFields),
                    responseTime: data.response.time,
                    errorMessage: data.error.message,
                    errorInstance: data.error.instance
                }
                this.logger.serviceLog(_log);
                if (eventOption && eventOption.kafkaEnable) {
                    this.kafkaLogger.send({ topics: 'service', message: _log });
                }
            } catch (err) {
                this.handleLogError(err, {
                    timestamp: Moment(data.timestamp).format(this.timestampFormat),
                    id: data.request.id,
                    ip: data.request.ip,
                    requestId: data.request.apiRequestId
                });
            }
        });
    }

    private static handleLogError(err: Error, requestInfo: IErrorLog): void {
        this.logger.rootLog({
            timestamp: requestInfo.timestamp,
            id: requestInfo.id,
            ip: requestInfo.ip,
            requestId: requestInfo.requestId,
            logMessage: err.stack || err.message
        });
    }

    private static isObject(obj: Object): Object {
        return obj && typeof obj === 'object' && !Array.isArray(obj);
    }

    private static isString(obj) {
        return obj && typeof obj === 'string';
    }

    private static logBody(requestBody: any, hiddenFields: Array<string>, hiddenPin?: Array<IOption>): Object {
        if (this.isObject(requestBody)) {
            hiddenFields
                .forEach((field: string) => {
                    if (requestBody.hasOwnProperty(field)) {
                        requestBody[field] = '***';
                    }
                });

            if (hiddenPin && hiddenPin.length > 0) {
                for (let word of hiddenPin) {
                    if (requestBody.hasOwnProperty(word.field)) {
                        requestBody[word.field] = requestBody[word.field].replace(requestBody[word.field].substring(word.start, word.end), 'xxxx');
                    }
                }
            }
        } else if (this.isString(requestBody)) {
            if (hiddenPin && hiddenPin.length > 0) {
                for (let word of hiddenPin) {
                    let match = requestBody.match(new RegExp(`(${word.field.toUpperCase()})([^(&amp;|&)]+)`))
                    if (match) {
                        let splitWord = match[0].split('=');
                        let replaceWord = splitWord[1].replace(splitWord[1].substring(1, 5), 'xxxx');
                        requestBody = requestBody.replace(splitWord[1], replaceWord);
                    }
                }
            }

        }
        return requestBody;
    }

    private static calculateResponseTime(request: Hapi.Request): number {
        let received: Moment.Moment = Moment(request.info.received);
        let responded: Moment.Moment = Moment(request.info.responded);
        let duration: Moment.Duration = Moment.duration(responded.diff(received));
        return duration.asMilliseconds();
    }
}