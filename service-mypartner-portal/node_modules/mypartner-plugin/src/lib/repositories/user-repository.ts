import * as Bluebird from "bluebird";
import { BaseRepository } from "./base-repository";
import {
    IRepository,
    IUser,
    IRequest,
    KeepAliveUserParams,
    GetUserTokenParams,
    GetEncryptTokenParams,
    ValidateSessionParams
} from "../interfaces";
import * as Crypto from "crypto";

export class UserRepository extends BaseRepository implements IRepository {

    public registerMethod = (): void => {
        console.log('regis user')
        this
            .server
            .method({
                name: 'Regis.saveUser',
                method: this.saveUser,
                options: {
                    callback: false
                }
            });

        this
            .server
            .method({
                name: 'Regis.keepAlive',
                method: this.keepAlive,
                options: {
                    callback: false
                }
            });

        this
            .server
            .method({
                name: 'Regis.validateSession',
                method: this.validateSession,
                options: {
                    callback: false
                }
            });


        this
            .server
            .method({
                name: 'Regis.getUserToken',
                method: this.getUserToken,
                options: {
                    callback: false
                }
            });

        this
            .server
            .method({
                name: 'Regis.getEncryptToken',
                method: this.getEncryptToken,
                options: {
                    callback: false
                }
            });
    }

    private saveUser = (request: any) => {
        let userRequestOptions: IUser = {
            SESSION_ID: request.payload.sessionId,
            USERNAME: request.payload.username,
            FULLNAME: request.payload.fullname,
            ROLE: request.payload.role,
            PARAMETER_TYPE: request.payload.type,
            PARAMETER_VALUE: request.payload.value,
            MY_CHANNEL_TOKEN: request.payload.myChannelToken
        }
        return this._saveUser(request, userRequestOptions)
    }

    private _saveUser = (request: IRequest, userRequestOptions: IUser): Bluebird<any> => {
        let reqOptions = this._getReqOptionsPost(request)
        reqOptions['uri'] = "/api/saveUser";
        reqOptions['headers']['Content-Type'] = 'application/json'
        reqOptions['body'] = {
            sessionId: userRequestOptions.SESSION_ID,
            username: userRequestOptions.USERNAME,
            fullname: userRequestOptions.FULLNAME,
            role: userRequestOptions.ROLE,
            type: userRequestOptions.PARAMETER_TYPE,
            value: userRequestOptions.PARAMETER_VALUE,
            myChannelToken: userRequestOptions.MY_CHANNEL_TOKEN
        }
        const loggerName = 'mychannel-service'
        var $this = this

        let db: any = this.getConnection();

        let responsePromise = new Promise(function (resolve, reject) {
            db.model('User').findOne({ USERNAME: userRequestOptions.USERNAME }).exec().then((user: IUser) => {
                var obj = {}
                if (user) {
                    db.model('User').findById(user["_id"], function (err, existUser) {
                        existUser.set(userRequestOptions);
                        existUser.save(function (err, updatedUser) {
                            obj["body"] = updatedUser;
                            $this.sendLog(reqOptions, loggerName, obj)
                            resolve(obj)
                        });
                    });
                } else {

                    let result = $this.createUser(userRequestOptions)

                    obj["body"] = result;

                    resolve(obj)
                }
            })


        });
        return responsePromise
    }

    private createUser = (userObj) => {
        let db: any = this.getConnection();

        const User = db.model('User');
        const user = new User(userObj);
        user.save()
    }

    private validateSession = (request: any) => {
        let keepAliveRequestOptions: KeepAliveUserParams = {
            TOKEN: request.payload.token,
            ACTION: request.payload.action
        }
        return this._validateSession(request, keepAliveRequestOptions)
    }

    private _validateSession = (request: IRequest, keepAliveRequestOptions: KeepAliveUserParams): Bluebird<any> => {
        let reqOptions = this._getReqOptionsPost(request)
        reqOptions['uri'] = "/api/validateSession";
        reqOptions['headers']['Content-Type'] = 'application/json'
        reqOptions['body'] = {
            token: keepAliveRequestOptions.TOKEN,
            action: keepAliveRequestOptions.ACTION,
        }
        const loggerName = 'mychannel-service'
        var $this = this

        let db: any = this.getConnection();

        let token = keepAliveRequestOptions.TOKEN
        var textString = this.decryptUserToken(token)
        let arrayToken = textString.split("|")
        let myChannelToken = arrayToken[7]

        let responsePromise = new Promise(function (resolve, reject) {
            db.model('User').findOne({ MY_CHANNEL_TOKEN: myChannelToken }).exec().then((user: IUser) => {
                if (user) {
                    // let obj = { "body": { "statusCode": "200", "message": "ok" } }
                    let obj = {
                        "body": {
                            "resultCode": "20000",
                            "resultDescription": "Success",
                            "developerMessage": "Success",
                            "data": {
                                "statusCode": "200",
                                "message": "ok"
                            }
                        }
                    }
                    $this.sendLog(reqOptions, loggerName, obj)
                    resolve(obj)
                } else {
                    // let obj = { "body": { "statusCode": "403", "message": "User Invalid!" } }
                    let obj = {
                        "body": {
                            "resultCode": "MYCHN00140300",
                            "resultDescription": "User Invalid!",
                            "developerMessage": "User Invalid!",
                            "errors": {
                                "statusCode": 403,
                                "error": "Forbidden",
                                "message": "User Invalid!"
                            }
                        }
                    }
                    $this.sendLog(reqOptions, loggerName, obj)
                    resolve(obj)
                }
            });
        });
        return responsePromise
    }

    private keepAlive = (request: any) => {
        let keepAliveRequestOptions: KeepAliveUserParams = {
            TOKEN: request.payload.token,
            ACTION: request.payload.action
        }
        return this._keepAlive(request, keepAliveRequestOptions)
    }

    private _keepAlive = (request: IRequest, keepAliveRequestOptions: KeepAliveUserParams): Bluebird<any> => {
        let reqOptions = this._getReqOptionsPost(request)
        reqOptions['uri'] = "/api/keepAlive";
        reqOptions['headers']['Content-Type'] = 'application/json'
        reqOptions['body'] = {
            token: keepAliveRequestOptions.TOKEN,
            action: keepAliveRequestOptions.ACTION,
        }
        const loggerName = 'mychannel-service'
        var $this = this

        let db: any = this.getConnection();

        let token = keepAliveRequestOptions.TOKEN
        var textString = this.decryptUserToken(token)
        let arrayToken = textString.split("|")
        let myChannelToken = arrayToken[7]

        let responsePromise = new Promise(function (resolve, reject) {
            db.model('User').findOne({ MY_CHANNEL_TOKEN: myChannelToken }).exec().then((user: IUser) => {
                if (user) {
                    let obj = { "body": { "statusCode": "200", "message": "ok" } }
                    $this.sendLog(reqOptions, loggerName, obj)
                    resolve(obj)
                } else {
                    let obj = { "body": { "statusCode": "403", "message": "User Invalid!" } }
                    $this.sendLog(reqOptions, loggerName, obj)
                    resolve(obj)
                }
            });
        });
        return responsePromise
    }

    private getEncryptToken = (request: any) => {
        let getEncryptTokenParamsOptions: GetEncryptTokenParams = {
            username: request.payload.username,
            location: request.payload.location,
            extSystem: request.payload.extSystem
        }
        return this._getEncryptToken(request, getEncryptTokenParamsOptions)
    }

    private _getEncryptToken = (request: IRequest, getEncryptTokenParamsOptions: GetEncryptTokenParams): Bluebird<any> => {
        let reqOptions = this._getReqOptionsPost(request)
        reqOptions['uri'] = "/api/getEncryptToken";
        reqOptions['headers']['Content-Type'] = 'application/json'
        reqOptions['body'] = {
            username: getEncryptTokenParamsOptions.username,
            location: getEncryptTokenParamsOptions.location,
            extSystem: getEncryptTokenParamsOptions.extSystem
        }
        const loggerName = 'mychannel-service'

        var $this = this
        console.log("reqOptions", reqOptions)
        let responsePromise = new Promise(function (resolve, reject) {

            let params = "?user=" + encodeURIComponent($this.encryptString(getEncryptTokenParamsOptions.username)) +
                "&locCode=" + encodeURIComponent($this.encryptString(getEncryptTokenParamsOptions.location)) +
                "&extSystem=" + encodeURIComponent($this.encryptString(getEncryptTokenParamsOptions.extSystem));
            let obj = {
                "body": {
                    "resultCode": "S",
                    "resultMessage": "Success",
                    "bypassUrl": $this.options['tdmUrl'] +
                        $this.options.urlList['x-path-getEncryptToken'] +
                        params
                }
            }
            $this.sendLog(reqOptions, loggerName, obj)
            resolve(obj)
        });
        return responsePromise
    }

    private getUserToken = (request: any) => {
        let getUserTokenParamsOptions: GetUserTokenParams = {
            MY_CHANNEL_TOKEN: request.payload.myChannelToken,
        }
        return this._getUserToken(request, getUserTokenParamsOptions)
    }

    private _getUserToken = (request: IRequest, getUserTokenParamsOptions: GetUserTokenParams): Bluebird<any> => {
        let reqOptions = this._getReqOptionsPost(request)
        reqOptions['uri'] = "/api/getUserToken";
        reqOptions['headers']['Content-Type'] = 'application/json'
        reqOptions['body'] = {
            myChannelToken: getUserTokenParamsOptions.MY_CHANNEL_TOKEN,
        }
        const loggerName = 'mychannel-service'

        var $this = this
        console.log("reqOptions", reqOptions)
        let db: any = this.getConnection();
        let myChannelToken = getUserTokenParamsOptions.MY_CHANNEL_TOKEN
        let responsePromise = new Promise(function (resolve, reject) {
            db.model('User').findOne({ MY_CHANNEL_TOKEN: myChannelToken }).exec().then((user: IUser) => {

                if (user) {
                    let obj = {
                        "body": {
                            "resultCode": "S",
                            "resultMessage": "Success",
                            "token": $this.encryptUserToken(user)
                        }
                    }
                    $this.sendLog(reqOptions, loggerName, obj)
                    resolve(obj)
                } else {
                    let obj = {
                        "body": {
                            "resultCode": "F",
                            "resultMessage": "Fail"
                        }
                    }
                    $this.sendLog(reqOptions, loggerName, obj)
                    resolve(obj)
                }

            });
        });
        return responsePromise
    }

    private encryptUserToken = (user: IUser): String => {
        let opt = this.options
        var aesDataMessage = user.SESSION_ID + "|"
            + user.USERNAME + "|"
            + user.FULLNAME + "|"
            + user.ROLE + "|"
            + user.PARAMETER_TYPE + "|"
            + user.PARAMETER_VALUE + "|"
            + opt.urlList["x-path-redirect"] + "|"
            + user.MY_CHANNEL_TOKEN;

        var cipher = Crypto.createCipheriv('aes-128-ecb', this.padString(opt.token['secret-token']), '');
        var crypted = cipher.update(aesDataMessage, 'utf-8', 'base64');
        crypted += cipher.final('base64');
        return crypted;
    }

    private decryptUserToken = (token: String): String => {
        var decipher = Crypto.createDecipheriv('aes-128-ecb', this.padString(this.options.token['secret-token']), '');
        var decrypted = decipher.update(token, 'base64');
        decrypted += decipher.final();
        return decrypted;
    }

    private encryptString = (text: String): String => {
        let opt = this.options

        var cipher = Crypto.createCipheriv('aes-128-ecb', this.padString(opt.token['secret-token']), '');
        var crypted = cipher.update(text, 'utf-8', 'base64');
        crypted += cipher.final('base64');
        return crypted;
    }

    private padString(str) {
        var range = 16;
        var length = (str.length % range);
        var i = (range - length)
        if ((i > 0) && (i < range)) {
            for (var j = (range - length); j > 0; j--) {
                str += ' '
            }
        }
        return str
    }
}
