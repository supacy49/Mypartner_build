import * as url from 'url';
import * as jwt from 'jsonwebtoken';

export interface KafkaOptions {
    url: string,
    headers?: any,
}

export interface LogOptions {
    topics: string;
    message: IKafkaLogService | any;
}

export interface IKafkaLogInfo {
    'TIMESTAMP': string;
    'ID': string;
    'IP': IDictionary<string> | string;
    'REQUEST_ID': IDictionary<string> | string;
    'REQUEST_METHOD': string;
    'REQUEST_URI': string;
    'REQUEST_HEADER': IDictionary<string>;
    'REQUEST_PARAMS': IDictionary<string>;
    'REQUEST_BODY': any;
    'RESPONSE_STATUS': number;
    'RESPONSE_BODY': any;
    'RESPONSE_TIME': number;
    'CLIENT_MODULE': string;
    'CLIENT_PAGE_NAME': string;
    'CLIENT_ACTION': string;
    'CLIENT_PAGE_URL': string;
}

export interface IKafkaLogService {
    'SERVICE_ENDPOINT': string
    'TIMESTAMP': string;
    'ID': string;
    'IP': IDictionary<string> | string;
    'REQUEST_ID': IDictionary<string> | string;
    'REQUEST_METHOD': string;
    'REQUEST_URI': string;
    'REQUEST_HEADER': IDictionary<string>;
    'REQUEST_PARAMS': IDictionary<string>;
    'REQUEST_BODY': any;
    'RESPONSE_STATUS': number;
    'RESPONSE_BODY': any;
    'RESPONSE_TIME': number;
    'ERROR_MESSAGE': string;
    'ERROR_INSTANCE': string;
}

interface IDictionary<T> {
    [key: string]: T;
}

interface IKafkaRequest {
    records: any[];
}

export class KafkaLogger {
    public options: any;

    constructor(options: KafkaOptions) {
        const defaultHeaders = {
            'Content-Type': 'application/vnd.kafka.json.v2+json',
            'Accept': 'application/vnd.kafka.v2+json'
        }
        this.options = Object.assign({}, options);
        if (!options.url) throw new Error('KafkaLogger: Missing URL');
        const parsedURL = url.parse(options.url);
        this.options.hostname = parsedURL.hostname;
        this.options.protocol = parsedURL.protocol;
        this.options.method = 'POST';
        if (typeof parsedURL.port !== 'undefined') this.options.port = parsedURL.port;
        this.options.headers = typeof this.options.headers !== 'undefined' ? { ...defaultHeaders, ...this.options.headers } : defaultHeaders
    }

    send(options: LogOptions): void {
        try {
            const message = this.parseLogMessage(options);

            if (
                (message.REQUEST_URI || '').indexOf('/swagger') > -1 ||
                (message.REQUEST_URI || '').indexOf('/swaggerui') > -1 ||
                (message.REQUEST_URI || '').indexOf('/documentation') > -1 ||
                (message.REQUEST_URI || '').indexOf('.css') > -1 ||
                (message.REQUEST_URI || '').indexOf('.js') > -1 ||
                (message.REQUEST_URI || '').indexOf('.png') > -1 ||
                (message.REQUEST_URI || '').indexOf('.jpg') > -1 ||
                (message.REQUEST_URI || '').indexOf('.ico') > -1 ||
                (message.REQUEST_URI || '').indexOf('.html') > -1
            ) { return; }

            const requestBody = this.getRequestBodyString(message);
            const topics: string = this.getTopics(options.topics);
            const requestOption = Object.assign({}, this.options, { path: `/topics/${topics}` });
            requestOption.headers = Object.assign(requestOption.headers, { 'Content-Length': Buffer.byteLength(requestBody) });
            const lib = requestOption.protocol.startsWith('https') ? require('https') : require('http');
            const request = lib.request(requestOption);
            request.on('response', (response: any) => response.on('end', () => { }).resume());
            request.on('error', (error: any) => console.warn('KafkaLogger', error));
            request.write(requestBody);
            request.end();
        } catch (error) {
            console.warn('KafkaLogger ', error);
        }
    }

    getTopics(topics: string) {
        try {
            const base = process.env.name ? process.env.name : require('path').basename(JSON.parse(process.env.LOG).PATH);
            return `${base}-${topics}`.toLowerCase().trim();
        } catch (error) {
            return 'mc-unknown';
        }
    }

    getRequestBodyString(message: any) {
        let record: string;
        try {
            let cache = [];
            record = JSON.stringify({ records: [{ value: message }] }, (key, value) => {
                if (typeof value === 'object' && value !== null) {
                    if (cache.indexOf(value) !== -1) {
                        return;
                    }
                    cache.push(value);
                }
                return value;
            });
            cache = null;
        }
        catch (error) {
            message.REQUEST_BODY = '';
            record = JSON.stringify(Object.assign({}, { records: [{ value: message }] }));
        }
        return record;
    }

    parseLogMessage(options) {
        let message = Object.assign({}, options.message);
        switch (options.topics) {
            case 'info':
                message = Object.assign({}, this.parseLogInfo(message));
                break;
            case 'service':
                message = Object.assign({}, this.parseLogService(message));
                break;
            default: break;
        }
        return message;
    }

    parseLogInfo(message: any): IKafkaLogInfo {
        const requestHeader = Object.assign({}, message.requestHeaders || {});
        const token = this.getToken(requestHeader);
        const header = Object.assign(requestHeader, { 'x-authorization': this.decodeJwt(token) });
        return {
            'TIMESTAMP': message.timestamp,
            'ID': message.id,
            'IP': message.ip,
            'REQUEST_ID': message.requestId,
            'REQUEST_METHOD': message.requestMethod,
            'REQUEST_URI': message.requestUri,
            'REQUEST_HEADER': header,
            'REQUEST_PARAMS': message.requestParams,
            'REQUEST_BODY': message.requestBody,
            'RESPONSE_STATUS': message.responseStatus,
            'RESPONSE_BODY': message.responseBody,
            'RESPONSE_TIME': message.responseTime,
            'CLIENT_MODULE': message.clientModule,
            'CLIENT_PAGE_NAME': message.clientPageName,
            'CLIENT_ACTION': message.clientAction,
            'CLIENT_PAGE_URL': message.clientPageUrl,
        };
    }

    getToken(requestHeader: any) {
        let token;
        try {
            token = (requestHeader && requestHeader['x-authorization']) ? requestHeader['x-authorization'] : '';
            token = token.split(' ')[1];
        } catch (error) {
            token = ''
        }
        return token
    }

    parseLogService(message: any): IKafkaLogService {
        const requestHeader = Object.assign({}, message.requestHeaders || {});
        const token = this.getToken(requestHeader);
        const header = Object.assign(requestHeader, { 'x-authorization': this.decodeJwt(token) });
        return {
            'SERVICE_ENDPOINT': (message && message.name) ? message.name : '-',
            'TIMESTAMP': message.timestamp,
            'ID': message.id,
            'IP': message.ip,
            'REQUEST_ID': message.requestId,
            'REQUEST_METHOD': message.requestMethod,
            'REQUEST_URI': message.requestUri,
            'REQUEST_HEADER': header,
            'REQUEST_PARAMS': message.requestParams,
            'REQUEST_BODY': message.requestBody,
            'RESPONSE_STATUS': message.responseStatus,
            'RESPONSE_BODY': message.responseBody,
            'RESPONSE_TIME': message.responseTime,
            'ERROR_MESSAGE': message.errorMessage,
            'ERROR_INSTANCE': message.errorInstance,
        };
    }

    decodeJwt(token: string) {
        const decoded = jwt.decode(token, { complete: true });
        try {
            return JSON.stringify(decoded.payload)
        } catch (error) {
            return token
        }
    }
}