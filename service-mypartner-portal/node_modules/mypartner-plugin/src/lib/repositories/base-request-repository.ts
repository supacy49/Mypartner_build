import * as Hapi from "hapi";
import * as Mongoose from "mongoose";
import * as Moment from 'moment'
import * as Request from 'request-promise'
import * as Boom from 'boom'
import * as Http from 'http'
import * as Url from 'url'
import {ILoggerData, IRequest} from "./../interfaces"
require('tls').DEFAULT_CIPHERS= 'RSA'

export class BaseRequestRepository {
    protected server: Hapi.Server
    protected options: any

    constructor(server: Hapi.Server, options: any) {
        this.server = server;
        this.options = options;
    }

    protected getConnection = (): Mongoose.Connection => {
      return this.server.plugins['hapi-mongoose'].connection;
    }
    
    protected _getLoggerData = (
        reqOptions: any,
        loggerName: string,
        startTime: Moment.Moment,
        response: any,
        error: any
    ) => {
        let now = Moment()
        let data: ILoggerData = {
            name: loggerName,
            timestamp: now.format('YYYY-MM-DD HH:mm:ss'),
            request: {
                id: reqOptions['id'],
                ip: reqOptions['ip'],
                apiRequestId: reqOptions['apiRequestId'],
                method: reqOptions['method'],
                uri: reqOptions['uri'],
                headers: reqOptions['headers'],
                params: reqOptions['qs'],
                body: reqOptions['body']
            },
            response: {
                status: response ? response.statusCode : error.statusCode,
                body: response ? response.body : null,
                time: Moment.duration(now.diff(startTime)).asMilliseconds()
            },
            error: {
                message: error ? error.message : null,
                instance: error ? error.name : null
            }
        }
        // console.log('data', data);
        return data
    }

    protected _getReqOptionsPost = (request: IRequest) => {
        return {
        method: 'POST',
        id: request.id,
        apiRequestId: request.apiRequestId,
        headers: this.options.headers,
        resolveWithFullResponse: true,
        timeout: this.options['timeout'] || 2000
        }
    }
    protected _getReqOptionsPostWithoutHeader = (request: IRequest) => {
        return {
        method: 'POST',
        id: request.id,
        apiRequestId: request.apiRequestId,
        headers: {},
        resolveWithFullResponse: true,
        timeout: this.options['timeout'] || 2000
        }
    }
    protected _getReqOptionsGet = (request: IRequest) => {
        return {
        method: 'GET',
        id: request.id,
        headers: this.options.headers,
        resolveWithFullResponse: true,
        timeout: this.options['timeout'] || 2000
        }
    }

    protected sendLog = (reqOptions: any, loggerName: string, response: any) => {
      let now = Moment()
      console.log('send : ', reqOptions)
      this.server.emit('service', this._getLoggerData(reqOptions, loggerName, now, response, null))
    }

    protected sendRequest = (reqOptions: any, loggerName: string) => {
        let responsePromise
        //if (this.options['eventName']) {
        let now = Moment()
        let logResponse = null
        let logError = null
        console.log('send : ', reqOptions)
    
        responsePromise = Request(reqOptions)
          .then(response => {
            logResponse = response
            this.server.emit('service', this._getLoggerData(reqOptions, loggerName, now, response, null))
            console.log('response==========> : ', response.body)
    
            return response
          })
          .catch(error => {
            logError = error
            this.server.emit('service', this._getLoggerData(reqOptions, loggerName, now, null, error))
            console.log('error==========> : ', error)
    
            throw error
          })

        return responsePromise.then(this._validateJsonObject)
    }

    // protected sendRequest = (reqOptions: any, loggerName: string) => {
    //     // let responsePromise
    //     //if (this.options['eventName']) {
    //     let now = Moment()
    //     let logResponse = null
    //     let logError = null
    //     console.log('send : ', reqOptions)
        
    //     var parseUrl = Url.parse(reqOptions.uri);
    
    //     var options = {
    //       "method": reqOptions.method,
    //       "hostname": parseUrl.host,
    //       "port": null,
    //       "path": parseUrl.path,
    //       "headers": reqOptions.headers
    //     }
    
    //     console.log("Option http params ===>", options)
    //     var responsePromise;
    //     switch (reqOptions.method) {
    //       case "GET":{
    //         responsePromise = new Promise(function(resolve, reject) {
    //           var req = Http.request(options, function (res) {
    //             var chunks = [];
            
    //             res.on("data", function (chunk) {
    //               chunks.push(chunk);
    //             });
            
    //             res.on("end", function () {
    //               var body = Buffer.concat(chunks);
    //               var obj = {}
    //               obj["body"] = JSON.parse(body.toString());
    //               console.log("obj ===>", obj)
    //               resolve(obj);
    //             });
    //           });
            
    //           req.end();
            
    //         });
    //         break;
    //       }
    //       case "POST":{
    //         responsePromise = new Promise(function(resolve, reject) {
    //           var req = Http.request(options, function (res) {
    //             var chunks = [];
            
    //             res.on("data", function (chunk) {
    //               chunks.push(chunk);
    //             });
            
    //             res.on("end", function () {
    //               var body = Buffer.concat(chunks);
                
    //               var obj = {}
    //               obj["body"] = JSON.parse(body.toString());
                  
    //               resolve(obj);
    //             });
    //           });
            
    //           req.write(JSON.stringify(reqOptions.body));
    //             req.end();
    //           });
    //         break;
    //       }
    //       default: { 
    //         console.log('other method')
    //         break; 
    //       } 
    //     }
    //     return responsePromise.then(this._validateJsonObject)
    //   }

    protected _validateJsonObject = response => {
        let body = response.body
        console.log(body)
        if (typeof body == 'object') {
          return response
        } else {
          throw Boom.create(500, 'JsonFormatError', {
            name: 'JsonFormatError',
            message: 'Incorrect JSON response',
            body: body
          })
        }
    }
    
}
