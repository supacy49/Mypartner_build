"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Moment = require("moment");
const Cron = require("cron");
const base_request_repository_1 = require("./base-request-repository");
require('tls').DEFAULT_CIPHERS = 'RSA';
class SearchApiRepository extends base_request_repository_1.BaseRequestRepository {
    constructor() {
        super(...arguments);
        this.registerMethod = () => {
            this.server.method({
                name: 'Regis.searchApi',
                method: this.searchApi,
                options: {
                    callback: false
                }
            });
            this.server.method({
                name: 'Regis.getSearchApi',
                method: this.getSearchApi,
                options: {
                    callback: false
                }
            });
            this.server.method({
                name: 'Regis.cronJob',
                method: this.cronJob,
                options: {
                    callback: false
                }
            });
        };
        this.cronJob = (request) => {
          /*  var CronJob = Cron.CronJob;
            var self = this;
            new CronJob(this.options.cron['recurring'], function () {
                self._saveQuerySearchApiByTag(request, "MostviewConfirm");
                self._saveQuerySearchApiByTag(request, "BestsellerConfirm");
            }, null, true, 'Asia/Bangkok');
            */
        };
        this._saveQuerySearchApiByTag = (request, tag) => {
            var self = this;
            let searchApiQueryOptions = {
                consumer: self.options.token['consumer-token'],
                tags: tag
            };
            var count = 1;
            self._querySearchApi(request, searchApiQueryOptions).then(result => {
                var response = self._saveProductData(result, searchApiQueryOptions);
                response.then(result => {
                    if (!result) {
                        self._querySearchApi(request, searchApiQueryOptions).then(result => {
                            self._saveProductData(result, searchApiQueryOptions).then(result => {
                                if (!result) {
                                    self._querySearchApi(request, searchApiQueryOptions).then(result => {
                                        self._saveProductData(result, searchApiQueryOptions);
                                    });
                                }
                            });
                        });
                    }
                });
            });
        };
        this.searchApi = (request) => {
            let searchApiQueryOptions = {
                consumer: request.payload.consumer,
                tags: request.payload.tags
            };
            return this._querySearchApi(request, searchApiQueryOptions);
        };
        this._querySearchApi = (request, searchApiQueryOptions) => {
            let reqOptions = this._getReqOptionsPostWithoutHeader(request);
            let now = Moment();
            reqOptions['certificate'] = 'tradingservice3.ais.co.th_2017.cer';
            reqOptions['rejectUnauthorized'] = false;
            reqOptions['uri'] = this.options['cpcUrl'] + this.options.urlList['x-path-searchApi'];
            reqOptions['headers']['Host'] = this.options.headers['Host'];
            reqOptions['headers']['Content-Type'] = 'application/json';
            reqOptions['body'] = {
                consumer: searchApiQueryOptions.consumer,
                tags: searchApiQueryOptions.tags
            };
            reqOptions['json'] = true;
            const loggerName = 'cpc-service';
            return this.sendRequest(reqOptions, loggerName);
        };
        this.getSearchApi = (request) => {
            let searchApiQueryOptions = {
                tags: request.payload.tags
            };
            return this._queryGetSearchApi(request, searchApiQueryOptions);
        };
        this._queryGetSearchApi = (request, searchApiQueryOptions) => {
            let reqOptions = this._getReqOptionsPost(request);
            reqOptions['uri'] = "/api/getUserToken";
            reqOptions['headers']['Content-Type'] = 'application/json';
            reqOptions['body'] = {
                tags: searchApiQueryOptions.tags,
            };
            const loggerName = 'mychannel-service';
            var $this = this;
            console.log("reqOptions", reqOptions);
            let db = this.getConnection();
            let tags = searchApiQueryOptions.tags;
            let responsePromise = new Promise(function (resolve, reject) {
                db.model('Product').find({ TAG: tags }).exec().then((products) => {
                    let obj = {
                        "body": {
                            "resultCode": "S",
                            "resultMessage": "Success",
                            "products": products
                        }
                    };
                    $this.sendLog(reqOptions, loggerName, obj);
                    resolve(obj);
                });
            });
            return responsePromise;
        };
    }
    _saveProductData(res, searchApiQueryOptions) {
        var response = false;
        var self = this;
        var promise = new Promise(function (resolve, reject) {
            let body = res.body;
            if (body.statusCode === "20000" && body.statusCode !== undefined) {
                let products = body.products;
                if (products.length > 0) {
                    let db = self.getConnection();
                    const Product = db.model('Product');
                    Product.remove({ "TAG": searchApiQueryOptions.tags }, (err) => {
                        if (err === null) {
                            products.forEach((element, index) => {
                                let productObj = {
                                    ROW_ID: "row_" + searchApiQueryOptions.tags.toLowerCase() + "_" + index,
                                    TAG: searchApiQueryOptions.tags,
                                    PRODUCT_ID: element.product_id,
                                    NAME: element.name,
                                    ATTRIBUTES: element.attributes,
                                    IMAGES: element.images,
                                    THUMBNAIL: element.thumbnail,
                                    VARIATIONS: element.variations,
                                    PRICE: element.price
                                };
                                let product = new Product(productObj);
                                product.save();
                            });
                        }
                    });
                    response = true;
                }
            }
            else {
                response = false;
            }
            resolve(response);
        });
        return promise;
    }
}
exports.SearchApiRepository = SearchApiRepository;
//# sourceMappingURL=search-api-repository.js.map